import numpy as np
from _typeshed import Incomplete
from typing import Sequence

def quaternion_mult(*quats: Sequence[float]) -> np.ndarray | list[float | np.ndarray]: ...
def quaternion_from_angle_axis(angle: float, axis: np.ndarray, axis_normalized: bool = ...) -> list[float]: ...
def angle_axis_from_quaternion(quaternion: Sequence[float]) -> Sequence[float]: ...
def quaternion_conjugate(quaternion: Sequence[float]) -> np.ndarray: ...
def rotate_vector(vector: np.ndarray, angle: float, axis: np.ndarray = ...) -> np.ndarray: ...
def thick_diagonal(dim: int, thickness: int = ...) -> np.ndarray: ...
def rotation_matrix(angle: float, axis: np.ndarray, homogeneous: bool = ...) -> np.ndarray: ...
def rotation_about_z(angle: float) -> np.ndarray: ...
def z_to_vector(vector: np.ndarray) -> np.ndarray: ...
def angle_of_vector(vector: Sequence[float] | np.ndarray) -> float: ...
def angle_between_vectors(v1: np.ndarray, v2: np.ndarray) -> np.ndarray: ...
def normalize(vect: np.ndarray | tuple[float], fall_back: Incomplete | None = ...) -> np.ndarray: ...
def get_unit_normal(v1: np.ndarray, v2: np.ndarray, tol: float = ...) -> np.ndarray: ...
def compass_directions(n: int = ..., start_vect: np.ndarray = ...) -> np.ndarray: ...
def regular_vertices(n: int, *, radius: float = ..., start_angle: float | None = ...) -> tuple[np.ndarray, float]: ...
def complex_to_R3(complex_num: complex) -> np.ndarray: ...
def R3_to_complex(point: Sequence[float]) -> np.ndarray: ...
def complex_func_to_R3_func(complex_func): ...
def center_of_mass(points: Sequence[float]) -> np.ndarray: ...
def midpoint(point1: Sequence[float], point2: Sequence[float]) -> float | np.ndarray: ...
def line_intersection(line1: Sequence[np.ndarray], line2: Sequence[np.ndarray]) -> np.ndarray: ...
def find_intersection(p0s: Sequence[np.ndarray], v0s: Sequence[np.ndarray], p1s: Sequence[np.ndarray], v1s: Sequence[np.ndarray], threshold: float = ...) -> Sequence[np.ndarray]: ...
def get_winding_number(points: Sequence[np.ndarray]) -> float: ...
def shoelace(x_y: np.ndarray) -> float: ...
def shoelace_direction(x_y: np.ndarray) -> str: ...
def cross2d(a, b): ...
def earclip_triangulation(verts: np.ndarray, ring_ends: list) -> list: ...
def cartesian_to_spherical(vec: Sequence[float]) -> np.ndarray: ...
def spherical_to_cartesian(spherical: Sequence[float]) -> np.ndarray: ...
def perpendicular_bisector(line: Sequence[np.ndarray], norm_vector=...) -> Sequence[np.ndarray]: ...

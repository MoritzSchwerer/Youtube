import numpy as np
import typing

def bezier(points: np.ndarray) -> typing.Callable[[float], int | typing.Iterable]: ...
def partial_bezier_points(points: np.ndarray, a: float, b: float) -> np.ndarray: ...
def partial_quadratic_bezier_points(points, a, b): ...
def interpolate(start: int, end: int, alpha: float) -> float: ...
def integer_interpolate(start: float, end: float, alpha: float) -> tuple[int, float]: ...
def mid(start: float, end: float) -> float: ...
def inverse_interpolate(start: float, end: float, value: float) -> np.ndarray: ...
def match_interpolate(new_start: float, new_end: float, old_start: float, old_end: float, old_value: float) -> np.ndarray: ...
def get_smooth_cubic_bezier_handle_points(points): ...
def get_smooth_handle_points(points: np.ndarray) -> tuple[np.ndarray, np.ndarray]: ...
def diag_to_matrix(l_and_u: tuple[int, int], diag: np.ndarray) -> np.ndarray: ...
def is_closed(points: tuple[np.ndarray, np.ndarray]) -> bool: ...
def proportions_along_bezier_curve_for_point(point: typing.Iterable[float | int], control_points: typing.Iterable[typing.Iterable[float | int]], round_to: float | int | None = ...) -> np.ndarray: ...
def point_lies_on_bezier(point: typing.Iterable[float | int], control_points: typing.Iterable[typing.Iterable[float | int]], round_to: float | int | None = ...) -> bool: ...

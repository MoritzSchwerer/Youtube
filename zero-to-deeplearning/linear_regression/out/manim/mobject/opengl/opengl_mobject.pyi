from manim.constants import *
from manim.utils.color import *
import numpy as np
from _typeshed import Incomplete
from manim import config as config, logger as logger
from manim.utils.bezier import integer_interpolate as integer_interpolate, interpolate as interpolate
from manim.utils.color import Colors as Colors
from manim.utils.iterables import batch_by_property as batch_by_property, list_update as list_update, listify as listify, make_even as make_even, resize_array as resize_array, resize_preserving_order as resize_preserving_order, resize_with_interpolation as resize_with_interpolation, uniq_chain as uniq_chain
from manim.utils.paths import straight_path as straight_path
from manim.utils.simple_functions import get_parameters as get_parameters
from manim.utils.space_ops import angle_between_vectors as angle_between_vectors, normalize as normalize, rotation_matrix_transpose as rotation_matrix_transpose
from typing import Iterable, Sequence

def affects_shader_info_id(func): ...

class OpenGLMobject:
    shader_dtype: Incomplete
    shader_folder: str
    points: Incomplete
    bounding_box: Incomplete
    rgbas: Incomplete
    is_fixed_in_frame: Incomplete
    is_fixed_orientation: Incomplete
    fixed_orientation_center: Incomplete
    gloss: Incomplete
    shadow: Incomplete
    name: Incomplete
    data: Incomplete
    uniforms: Incomplete
    opacity: Incomplete
    dim: Incomplete
    render_primitive: Incomplete
    texture_paths: Incomplete
    depth_test: Incomplete
    listen_to_events: Incomplete
    parents: Incomplete
    parent: Incomplete
    family: Incomplete
    locked_data_keys: Incomplete
    needs_new_bounding_box: bool
    model_matrix: Incomplete
    color: Incomplete
    shader_indices: Incomplete
    should_render: Incomplete
    def __init__(self, color=..., opacity: int = ..., dim: int = ..., gloss: float = ..., shadow: float = ..., render_primitive=..., texture_paths: Incomplete | None = ..., depth_test: bool = ..., is_fixed_in_frame: bool = ..., is_fixed_orientation: bool = ..., listen_to_events: bool = ..., model_matrix: Incomplete | None = ..., should_render: bool = ..., name: str | None = ..., **kwargs) -> None: ...
    @classmethod
    def __init_subclass__(cls, **kwargs) -> None: ...
    def __sub__(self, other): ...
    def __isub__(self, other): ...
    def __add__(self, mobject): ...
    def __iadd__(self, mobject): ...
    @classmethod
    def set_default(cls, **kwargs) -> None: ...
    def init_data(self) -> None: ...
    def init_colors(self) -> None: ...
    def init_points(self) -> None: ...
    def set(self, **kwargs) -> OpenGLMobject: ...
    def set_data(self, data): ...
    def set_uniforms(self, uniforms): ...
    @property
    def animate(self): ...
    @property
    def width(self): ...
    @property
    def height(self): ...
    @property
    def depth(self): ...
    def resize_points(self, new_length, resize_func=...): ...
    def set_points(self, points): ...
    def apply_over_attr_arrays(self, func): ...
    def append_points(self, new_points): ...
    def reverse_points(self): ...
    def get_midpoint(self) -> np.ndarray: ...
    def apply_points_function(self, func, about_point: Incomplete | None = ..., about_edge=..., works_on_bounding_box: bool = ...): ...
    def match_points(self, mobject) -> None: ...
    def clear_points(self) -> None: ...
    def get_num_points(self): ...
    def get_all_points(self): ...
    def has_points(self): ...
    def get_bounding_box(self): ...
    def compute_bounding_box(self): ...
    def refresh_bounding_box(self, recurse_down: bool = ..., recurse_up: bool = ...): ...
    def is_point_touching(self, point, buff=...): ...
    def __getitem__(self, value): ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def split(self): ...
    def assemble_family(self): ...
    def get_family(self, recurse: bool = ...): ...
    def family_members_with_points(self): ...
    def add(self, *mobjects: OpenGLMobject, update_parent: bool = ...) -> OpenGLMobject: ...
    def insert(self, index: int, mobject: OpenGLMobject, update_parent: bool = ...): ...
    def remove(self, *mobjects: OpenGLMobject, update_parent: bool = ...) -> OpenGLMobject: ...
    def add_to_back(self, *mobjects: OpenGLMobject) -> OpenGLMobject: ...
    def replace_submobject(self, index, new_submob): ...
    def invert(self, recursive: bool = ...) -> None: ...
    def arrange(self, direction=..., center: bool = ..., **kwargs): ...
    def arrange_in_grid(self, rows: int | None = ..., cols: int | None = ..., buff: float | tuple[float, float] = ..., cell_alignment: np.ndarray = ..., row_alignments: str | None = ..., col_alignments: str | None = ..., row_heights: Iterable[float | None] | None = ..., col_widths: Iterable[float | None] | None = ..., flow_order: str = ..., **kwargs) -> OpenGLMobject: ...
    def get_grid(self, n_rows, n_cols, height: Incomplete | None = ..., **kwargs): ...
    def duplicate(self, n: int): ...
    def sort(self, point_to_num_func=..., submob_func: Incomplete | None = ...): ...
    def shuffle(self, recurse: bool = ...): ...
    def invert(self, recursive: bool = ...) -> None: ...
    def copy(self, shallow: bool = ...): ...
    def deepcopy(self): ...
    target: Incomplete
    def generate_target(self, use_deepcopy: bool = ...): ...
    saved_state: Incomplete
    def save_state(self, use_deepcopy: bool = ...): ...
    def restore(self): ...
    time_based_updaters: Incomplete
    non_time_updaters: Incomplete
    has_updaters: bool
    updating_suspended: bool
    def init_updaters(self) -> None: ...
    def update(self, dt: int = ..., recurse: bool = ...): ...
    def get_time_based_updaters(self): ...
    def has_time_based_updater(self): ...
    def get_updaters(self): ...
    def get_family_updaters(self): ...
    def add_updater(self, update_function, index: Incomplete | None = ..., call_updater: bool = ...): ...
    def remove_updater(self, update_function): ...
    def clear_updaters(self, recurse: bool = ...): ...
    def match_updaters(self, mobject): ...
    def suspend_updating(self, recurse: bool = ...): ...
    def resume_updating(self, recurse: bool = ..., call_updater: bool = ...): ...
    def refresh_has_updater_status(self): ...
    def shift(self, vector): ...
    def scale(self, scale_factor: float, about_point: Sequence[float] | None = ..., about_edge: Sequence[float] = ..., **kwargs) -> OpenGLMobject: ...
    def stretch(self, factor, dim, **kwargs): ...
    def rotate_about_origin(self, angle, axis=...): ...
    def rotate(self, angle, axis=..., about_point: Sequence[float] | None = ..., **kwargs): ...
    def flip(self, axis=..., **kwargs): ...
    def apply_function(self, function, **kwargs): ...
    def apply_function_to_position(self, function): ...
    def apply_function_to_submobject_positions(self, function): ...
    def apply_matrix(self, matrix, **kwargs): ...
    def apply_complex_function(self, function, **kwargs): ...
    def hierarchical_model_matrix(self): ...
    def wag(self, direction=..., axis=..., wag_factor: float = ...): ...
    def center(self): ...
    def align_on_border(self, direction, buff=...): ...
    def to_corner(self, corner=..., buff=...): ...
    def to_edge(self, edge=..., buff=...): ...
    def next_to(self, mobject_or_point, direction=..., buff=..., aligned_edge=..., submobject_to_align: Incomplete | None = ..., index_of_submobject_to_align: Incomplete | None = ..., coor_mask=...): ...
    def shift_onto_screen(self, **kwargs): ...
    def is_off_screen(self): ...
    def stretch_about_point(self, factor, dim, point): ...
    def rescale_to_fit(self, length, dim, stretch: bool = ..., **kwargs): ...
    def stretch_to_fit_width(self, width, **kwargs): ...
    def stretch_to_fit_height(self, height, **kwargs): ...
    def stretch_to_fit_depth(self, depth, **kwargs): ...
    def set_width(self, width, stretch: bool = ..., **kwargs): ...
    scale_to_fit_width = set_width
    def set_height(self, height, stretch: bool = ..., **kwargs): ...
    scale_to_fit_height = set_height
    def set_depth(self, depth, stretch: bool = ..., **kwargs): ...
    scale_to_fit_depth = set_depth
    def set_coord(self, value, dim, direction=...): ...
    def set_x(self, x, direction=...): ...
    def set_y(self, y, direction=...): ...
    def set_z(self, z, direction=...): ...
    def space_out_submobjects(self, factor: float = ..., **kwargs): ...
    def move_to(self, point_or_mobject, aligned_edge=..., coor_mask=...): ...
    def replace(self, mobject, dim_to_match: int = ..., stretch: bool = ...): ...
    def surround(self, mobject: OpenGLMobject, dim_to_match: int = ..., stretch: bool = ..., buff: float = ...): ...
    def put_start_and_end_on(self, start, end): ...
    def set_rgba_array(self, color: Incomplete | None = ..., opacity: Incomplete | None = ..., name: str = ..., recurse: bool = ...): ...
    def set_rgba_array_direct(self, rgbas: np.ndarray, name: str = ..., recurse: bool = ...): ...
    def set_color(self, color, opacity: Incomplete | None = ..., recurse: bool = ...): ...
    def set_opacity(self, opacity, recurse: bool = ...): ...
    def get_color(self): ...
    def get_opacity(self): ...
    def set_color_by_gradient(self, *colors): ...
    def set_submobject_colors_by_gradient(self, *colors): ...
    def fade(self, darkness: float = ..., recurse: bool = ...) -> None: ...
    def get_gloss(self): ...
    def set_gloss(self, gloss, recurse: bool = ...): ...
    def get_shadow(self): ...
    def set_shadow(self, shadow, recurse: bool = ...): ...
    background_rectangle: Incomplete
    def add_background_rectangle(self, color: Colors | None = ..., opacity: float = ..., **kwargs): ...
    def add_background_rectangle_to_submobjects(self, **kwargs): ...
    def add_background_rectangle_to_family_members_with_points(self, **kwargs): ...
    def get_bounding_box_point(self, direction): ...
    def get_edge_center(self, direction) -> np.ndarray: ...
    def get_corner(self, direction) -> np.ndarray: ...
    def get_center(self) -> np.ndarray: ...
    def get_center_of_mass(self): ...
    def get_boundary_point(self, direction): ...
    def get_continuous_bounding_box_point(self, direction): ...
    def get_top(self) -> np.ndarray: ...
    def get_bottom(self) -> np.ndarray: ...
    def get_right(self) -> np.ndarray: ...
    def get_left(self) -> np.ndarray: ...
    def get_zenith(self) -> np.ndarray: ...
    def get_nadir(self) -> np.ndarray: ...
    def length_over_dim(self, dim): ...
    def get_width(self): ...
    def get_height(self): ...
    def get_depth(self): ...
    def get_coord(self, dim: int, direction=...): ...
    def get_x(self, direction=...) -> np.float64: ...
    def get_y(self, direction=...) -> np.float64: ...
    def get_z(self, direction=...) -> np.float64: ...
    def get_start(self): ...
    def get_end(self): ...
    def get_start_and_end(self): ...
    def point_from_proportion(self, alpha): ...
    def pfp(self, alpha): ...
    def get_pieces(self, n_pieces): ...
    def get_z_index_reference_point(self): ...
    def match_color(self, mobject: OpenGLMobject): ...
    def match_dim_size(self, mobject: OpenGLMobject, dim, **kwargs): ...
    def match_width(self, mobject: OpenGLMobject, **kwargs): ...
    def match_height(self, mobject: OpenGLMobject, **kwargs): ...
    def match_depth(self, mobject: OpenGLMobject, **kwargs): ...
    def match_coord(self, mobject: OpenGLMobject, dim, direction=...): ...
    def match_x(self, mobject, direction=...): ...
    def match_y(self, mobject, direction=...): ...
    def match_z(self, mobject, direction=...): ...
    def align_to(self, mobject_or_point: OpenGLMobject | Sequence[float], direction=...): ...
    def get_group_class(self): ...
    @staticmethod
    def get_mobject_type_class(): ...
    def align_data_and_family(self, mobject) -> None: ...
    def align_data(self, mobject) -> None: ...
    def align_points(self, mobject): ...
    def align_family(self, mobject): ...
    def push_self_into_submobjects(self): ...
    def add_n_more_submobjects(self, n): ...
    def interpolate(self, mobject1, mobject2, alpha, path_func=...): ...
    def pointwise_become_partial(self, mobject, a, b) -> None: ...
    def become(self, mobject: OpenGLMobject, match_height: bool = ..., match_width: bool = ..., match_depth: bool = ..., match_center: bool = ..., stretch: bool = ...): ...
    def lock_data(self, keys) -> None: ...
    def lock_matching_data(self, mobject1, mobject2): ...
    def unlock_data(self) -> None: ...
    def fix_in_frame(self): ...
    def fix_orientation(self): ...
    def unfix_from_frame(self): ...
    def unfix_orientation(self): ...
    def apply_depth_test(self): ...
    def deactivate_depth_test(self): ...
    def replace_shader_code(self, old, new): ...
    def set_color_by_code(self, glsl_code): ...
    def set_color_by_xyz_func(self, glsl_snippet, min_value=..., max_value: float = ..., colormap: str = ...): ...
    def refresh_shader_wrapper_id(self): ...
    shader_wrapper: Incomplete
    def get_shader_wrapper(self): ...
    def get_shader_wrapper_list(self): ...
    def check_data_alignment(self, array, data_key): ...
    def get_resized_shader_data_array(self, length): ...
    def read_data_to_shader(self, shader_data, shader_data_key, data_key) -> None: ...
    def get_shader_data(self): ...
    def refresh_shader_data(self) -> None: ...
    def get_shader_uniforms(self): ...
    def get_shader_vert_indices(self): ...
    @property
    def submobjects(self): ...
    def throw_error_if_no_points(self) -> None: ...

class OpenGLGroup(OpenGLMobject):
    def __init__(self, *mobjects, **kwargs) -> None: ...

class OpenGLPoint(OpenGLMobject):
    artificial_width: Incomplete
    artificial_height: Incomplete
    def __init__(self, location=..., artificial_width: float = ..., artificial_height: float = ..., **kwargs) -> None: ...
    def get_width(self): ...
    def get_height(self): ...
    def get_location(self): ...
    def get_bounding_box_point(self, *args, **kwargs): ...
    def set_location(self, new_loc) -> None: ...

class _AnimationBuilder:
    mobject: Incomplete
    overridden_animation: Incomplete
    is_chaining: bool
    methods: Incomplete
    cannot_pass_args: bool
    anim_args: Incomplete
    def __init__(self, mobject) -> None: ...
    def __call__(self, **kwargs): ...
    def __getattr__(self, method_name): ...
    def build(self): ...

def override_animate(method): ...

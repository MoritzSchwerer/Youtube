from ..constants import *
import numpy as np
from ..animation.animation import Animation
from ..utils.color import Colors
from _typeshed import Incomplete
from colour import Color
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from typing import Callable, Iterable, Sequence, TypeVar

T = TypeVar('T', bound='Mobject')

class Mobject:
    animation_overrides: Incomplete
    @classmethod
    def __init_subclass__(cls, **kwargs) -> None: ...
    name: Incomplete
    dim: Incomplete
    target: Incomplete
    z_index: Incomplete
    point_hash: Incomplete
    submobjects: Incomplete
    updaters: Incomplete
    updating_suspended: bool
    color: Incomplete
    def __init__(self, color=..., name: Incomplete | None = ..., dim: int = ..., target: Incomplete | None = ..., z_index: int = ...) -> None: ...
    @classmethod
    def animation_override_for(cls, animation_class: type[Animation]) -> Callable[[Mobject, ...], Animation] | None: ...
    @classmethod
    def add_animation_override(cls, animation_class: type[Animation], override_func: Callable[[Mobject, ...], Animation]): ...
    @classmethod
    def set_default(cls, **kwargs) -> None: ...
    @property
    def animate(self) -> _AnimationBuilder | T: ...
    def __deepcopy__(self, clone_from_id): ...
    points: Incomplete
    def reset_points(self) -> None: ...
    def init_colors(self) -> None: ...
    def generate_points(self) -> None: ...
    def add(self, *mobjects: Mobject): ...
    def insert(self, index: int, mobject: Mobject): ...
    def __add__(self, mobject) -> None: ...
    def __iadd__(self, mobject) -> None: ...
    def add_to_back(self, *mobjects: Mobject): ...
    def remove(self, *mobjects: Mobject): ...
    def __sub__(self, other) -> None: ...
    def __isub__(self, other) -> None: ...
    def set(self, **kwargs): ...
    def __getattr__(self, attr): ...
    @property
    def width(self): ...
    @property
    def height(self): ...
    @property
    def depth(self): ...
    def get_array_attrs(self): ...
    def apply_over_attr_arrays(self, func): ...
    def get_image(self, camera: Incomplete | None = ...): ...
    def show(self, camera: Incomplete | None = ...) -> None: ...
    def save_image(self, name: Incomplete | None = ...) -> None: ...
    def copy(self) -> T: ...
    def generate_target(self, use_deepcopy: bool = ...): ...
    def update(self, dt: float = ..., recursive: bool = ...): ...
    def get_time_based_updaters(self) -> list[Updater]: ...
    def has_time_based_updater(self) -> bool: ...
    def get_updaters(self) -> list[Updater]: ...
    def get_family_updaters(self): ...
    def add_updater(self, update_function: Updater, index: int | None = ..., call_updater: bool = ...): ...
    def remove_updater(self, update_function: Updater): ...
    def clear_updaters(self, recursive: bool = ...): ...
    def match_updaters(self, mobject: Mobject): ...
    def suspend_updating(self, recursive: bool = ...): ...
    def resume_updating(self, recursive: bool = ...): ...
    def apply_to_family(self, func: Callable[[Mobject], None]): ...
    def shift(self, *vectors: np.ndarray): ...
    def scale(self, scale_factor: float, **kwargs): ...
    def rotate_about_origin(self, angle, axis=..., axes=...): ...
    def rotate(self, angle, axis=..., about_point: Sequence[float] | None = ..., **kwargs): ...
    def flip(self, axis=..., **kwargs): ...
    def stretch(self, factor, dim, **kwargs): ...
    def apply_function(self, function, **kwargs): ...
    def apply_function_to_position(self, function): ...
    def apply_function_to_submobject_positions(self, function): ...
    def apply_matrix(self, matrix, **kwargs): ...
    def apply_complex_function(self, function, **kwargs): ...
    def wag(self, direction=..., axis=..., wag_factor: float = ...): ...
    def reverse_points(self): ...
    def repeat(self, count: int): ...
    def apply_points_function_about_point(self, func, about_point: Incomplete | None = ..., about_edge: Incomplete | None = ...): ...
    def pose_at_angle(self, **kwargs): ...
    def center(self): ...
    def align_on_border(self, direction, buff=...): ...
    def to_corner(self, corner=..., buff=...): ...
    def to_edge(self, edge=..., buff=...): ...
    def next_to(self, mobject_or_point, direction=..., buff=..., aligned_edge=..., submobject_to_align: Incomplete | None = ..., index_of_submobject_to_align: Incomplete | None = ..., coor_mask=...): ...
    def shift_onto_screen(self, **kwargs): ...
    def is_off_screen(self): ...
    def stretch_about_point(self, factor, dim, point): ...
    def rescale_to_fit(self, length, dim, stretch: bool = ..., **kwargs): ...
    def scale_to_fit_width(self, width, **kwargs): ...
    def stretch_to_fit_width(self, width, **kwargs): ...
    def scale_to_fit_height(self, height, **kwargs): ...
    def stretch_to_fit_height(self, height, **kwargs): ...
    def scale_to_fit_depth(self, depth, **kwargs): ...
    def stretch_to_fit_depth(self, depth, **kwargs): ...
    def set_coord(self, value, dim, direction=...): ...
    def set_x(self, x, direction=...): ...
    def set_y(self, y, direction=...): ...
    def set_z(self, z, direction=...): ...
    def space_out_submobjects(self, factor: float = ..., **kwargs): ...
    def move_to(self, point_or_mobject, aligned_edge=..., coor_mask=...): ...
    def replace(self, mobject, dim_to_match: int = ..., stretch: bool = ...): ...
    def surround(self, mobject: Mobject, dim_to_match: int = ..., stretch: bool = ..., buff=...): ...
    def put_start_and_end_on(self, start, end): ...
    background_rectangle: Incomplete
    def add_background_rectangle(self, color: Colors | None = ..., opacity: float = ..., **kwargs): ...
    def add_background_rectangle_to_submobjects(self, **kwargs): ...
    def add_background_rectangle_to_family_members_with_points(self, **kwargs): ...
    def set_color(self, color: Color = ..., family: bool = ...): ...
    def set_color_by_gradient(self, *colors): ...
    def set_colors_by_radial_gradient(self, center: Incomplete | None = ..., radius: int = ..., inner_color=..., outer_color=...): ...
    def set_submobject_colors_by_gradient(self, *colors): ...
    def set_submobject_colors_by_radial_gradient(self, center: Incomplete | None = ..., radius: int = ..., inner_color=..., outer_color=...): ...
    def to_original_color(self): ...
    def fade_to(self, color, alpha, family: bool = ...): ...
    def fade(self, darkness: float = ..., family: bool = ...): ...
    def get_color(self): ...
    saved_state: Incomplete
    def save_state(self): ...
    def restore(self): ...
    def reduce_across_dimension(self, points_func, reduce_func, dim): ...
    def nonempty_submobjects(self): ...
    def get_merged_array(self, array_attr): ...
    def get_all_points(self): ...
    def get_points_defining_boundary(self): ...
    def get_num_points(self): ...
    def get_extremum_along_dim(self, points: Incomplete | None = ..., dim: int = ..., key: int = ...): ...
    def get_critical_point(self, direction): ...
    def get_edge_center(self, direction) -> np.ndarray: ...
    def get_corner(self, direction) -> np.ndarray: ...
    def get_center(self) -> np.ndarray: ...
    def get_center_of_mass(self): ...
    def get_boundary_point(self, direction): ...
    def get_midpoint(self) -> np.ndarray: ...
    def get_top(self) -> np.ndarray: ...
    def get_bottom(self) -> np.ndarray: ...
    def get_right(self) -> np.ndarray: ...
    def get_left(self) -> np.ndarray: ...
    def get_zenith(self) -> np.ndarray: ...
    def get_nadir(self) -> np.ndarray: ...
    def length_over_dim(self, dim): ...
    def get_coord(self, dim, direction=...): ...
    def get_x(self, direction=...) -> np.float64: ...
    def get_y(self, direction=...) -> np.float64: ...
    def get_z(self, direction=...) -> np.float64: ...
    def get_start(self): ...
    def get_end(self): ...
    def get_start_and_end(self): ...
    def point_from_proportion(self, alpha) -> None: ...
    def proportion_from_point(self, point) -> None: ...
    def get_pieces(self, n_pieces): ...
    def get_z_index_reference_point(self): ...
    def has_points(self) -> bool: ...
    def has_no_points(self) -> bool: ...
    def match_color(self, mobject: Mobject): ...
    def match_dim_size(self, mobject: Mobject, dim, **kwargs): ...
    def match_width(self, mobject: Mobject, **kwargs): ...
    def match_height(self, mobject: Mobject, **kwargs): ...
    def match_depth(self, mobject: Mobject, **kwargs): ...
    def match_coord(self, mobject: Mobject, dim, direction=...): ...
    def match_x(self, mobject: Mobject, direction=...): ...
    def match_y(self, mobject: Mobject, direction=...): ...
    def match_z(self, mobject: Mobject, direction=...): ...
    def align_to(self, mobject_or_point: Mobject | np.ndarray | list, direction=..., alignment_vect=...): ...
    def __getitem__(self, value): ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def get_group_class(self): ...
    @staticmethod
    def get_mobject_type_class(): ...
    def split(self): ...
    def get_family(self, recurse: bool = ...): ...
    def family_members_with_points(self): ...
    def arrange(self, direction: Sequence[float] = ..., buff=..., center: bool = ..., **kwargs): ...
    def arrange_in_grid(self, rows: int | None = ..., cols: int | None = ..., buff: float | tuple[float, float] = ..., cell_alignment: np.ndarray = ..., row_alignments: str | None = ..., col_alignments: str | None = ..., row_heights: Iterable[float | None] | None = ..., col_widths: Iterable[float | None] | None = ..., flow_order: str = ..., **kwargs): ...
    def sort(self, point_to_num_func=..., submob_func: Incomplete | None = ...): ...
    def shuffle(self, recursive: bool = ...) -> None: ...
    def invert(self, recursive: bool = ...) -> None: ...
    def arrange_submobjects(self, *args, **kwargs): ...
    def sort_submobjects(self, *args, **kwargs): ...
    def shuffle_submobjects(self, *args, **kwargs): ...
    def align_data(self, mobject: Mobject, skip_point_alignment: bool = ...): ...
    def get_point_mobject(self, center: Incomplete | None = ...) -> None: ...
    def align_points(self, mobject): ...
    def align_points_with_larger(self, larger_mobject) -> None: ...
    def align_submobjects(self, mobject): ...
    def null_point_align(self, mobject: Mobject): ...
    def push_self_into_submobjects(self): ...
    def add_n_more_submobjects(self, n): ...
    def repeat_submobject(self, submob): ...
    def interpolate(self, mobject1, mobject2, alpha, path_func=...): ...
    def interpolate_color(self, mobject1, mobject2, alpha) -> None: ...
    def become(self, mobject: Mobject, copy_submobjects: bool = ..., match_height: bool = ..., match_width: bool = ..., match_depth: bool = ..., match_center: bool = ..., stretch: bool = ...): ...
    def match_points(self, mobject: Mobject, copy_submobjects: bool = ...): ...
    def throw_error_if_no_points(self) -> None: ...
    def set_z_index(self, z_index_value: float, family: bool = ...) -> VMobject: ...
    def set_z_index_by_z_coordinate(self): ...

class Group(Mobject, metaclass=ConvertToOpenGL):
    def __init__(self, *mobjects, **kwargs) -> None: ...

class _AnimationBuilder:
    mobject: Incomplete
    overridden_animation: Incomplete
    is_chaining: bool
    methods: Incomplete
    cannot_pass_args: bool
    anim_args: Incomplete
    def __init__(self, mobject) -> None: ...
    def __call__(self, **kwargs): ...
    def __getattr__(self, method_name): ...
    def build(self): ...

def override_animate(method): ...

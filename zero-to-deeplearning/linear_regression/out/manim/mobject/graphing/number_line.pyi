from manim.constants import *
import numpy as np
from _typeshed import Incomplete
from manim.mobject.geometry.line import Line
from manim.mobject.graphing.scale import _ScaleBase
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from typing import Iterable, Sequence

class NumberLine(Line):
    x_range: Incomplete
    length: Incomplete
    unit_size: Incomplete
    include_ticks: Incomplete
    tick_size: Incomplete
    numbers_with_elongated_ticks: Incomplete
    longer_tick_multiple: Incomplete
    exclude_origin_tick: Incomplete
    rotation: Incomplete
    include_tip: Incomplete
    tip_width: Incomplete
    tip_height: Incomplete
    font_size: Incomplete
    include_numbers: Incomplete
    label_direction: Incomplete
    label_constructor: Incomplete
    line_to_number_buff: Incomplete
    decimal_number_config: Incomplete
    numbers_to_exclude: Incomplete
    numbers_to_include: Incomplete
    scaling: Incomplete
    def __init__(self, x_range: Sequence[float] | None = ..., length: float | None = ..., unit_size: float = ..., include_ticks: bool = ..., tick_size: float = ..., numbers_with_elongated_ticks: Iterable[float] | None = ..., longer_tick_multiple: int = ..., exclude_origin_tick: bool = ..., rotation: float = ..., stroke_width: float = ..., include_tip: bool = ..., tip_width: float = ..., tip_height: float = ..., include_numbers: bool = ..., font_size: float = ..., label_direction: Sequence[float] = ..., label_constructor: VMobject = ..., scaling: _ScaleBase = ..., line_to_number_buff: float = ..., decimal_number_config: dict | None = ..., numbers_to_exclude: Iterable[float] | None = ..., numbers_to_include: Iterable[float] | None = ..., **kwargs) -> None: ...
    def rotate_about_zero(self, angle: float, axis: Sequence[float] = ..., **kwargs): ...
    def rotate_about_number(self, number: float, angle: float, axis: Sequence[float] = ..., **kwargs): ...
    ticks: Incomplete
    def add_ticks(self) -> None: ...
    def get_tick(self, x: float, size: float | None = ...) -> Line: ...
    def get_tick_marks(self) -> VGroup: ...
    def get_tick_range(self) -> np.ndarray: ...
    def number_to_point(self, number: float | np.ndarray) -> np.ndarray: ...
    def point_to_number(self, point: Sequence[float]) -> float: ...
    def n2p(self, number: float | np.ndarray) -> np.ndarray: ...
    def p2n(self, point: Sequence[float]) -> float: ...
    def get_unit_size(self) -> float: ...
    def get_unit_vector(self) -> np.ndarray: ...
    def get_number_mobject(self, x: float, direction: Sequence[float] | None = ..., buff: float | None = ..., font_size: float | None = ..., label_constructor: VMobject | None = ..., **number_config) -> VMobject: ...
    def get_number_mobjects(self, *numbers, **kwargs) -> VGroup: ...
    def get_labels(self) -> VGroup: ...
    numbers: Incomplete
    def add_numbers(self, x_values: Iterable[float] | None = ..., excluding: Iterable[float] | None = ..., font_size: float | None = ..., label_constructor: VMobject | None = ..., **kwargs): ...
    labels: Incomplete
    def add_labels(self, dict_values: dict[float, str | float | VMobject], direction: Sequence[float] = ..., buff: float | None = ..., font_size: float | None = ..., label_constructor: VMobject | None = ...): ...

class UnitInterval(NumberLine):
    def __init__(self, unit_size: int = ..., numbers_with_elongated_ticks: Incomplete | None = ..., decimal_number_config: Incomplete | None = ..., **kwargs) -> None: ...

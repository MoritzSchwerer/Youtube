from manim.constants import *
import numpy as np
from _typeshed import Incomplete
from colour import Color
from manim.mobject.geometry.line import Line
from manim.mobject.graphing.functions import ImplicitFunction, ParametricFunction
from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.types.vectorized_mobject import VDict, VGroup, VMobject
from typing import Callable, Iterable, Sequence

class CoordinateSystem:
    dimension: Incomplete
    x_range: Incomplete
    y_range: Incomplete
    x_length: Incomplete
    y_length: Incomplete
    num_sampled_graph_points_per_tick: int
    def __init__(self, x_range: Incomplete | None = ..., y_range: Incomplete | None = ..., x_length: Incomplete | None = ..., y_length: Incomplete | None = ..., dimension: int = ...) -> None: ...
    def coords_to_point(self, *coords) -> None: ...
    def point_to_coords(self, point) -> None: ...
    def polar_to_point(self, radius: float, azimuth: float) -> np.ndarray: ...
    def point_to_polar(self, point: np.ndarray) -> tuple[float, float]: ...
    def c2p(self, *coords): ...
    def p2c(self, point): ...
    def pr2pt(self, radius: float, azimuth: float) -> np.ndarray: ...
    def pt2pr(self, point: np.ndarray) -> tuple[float, float]: ...
    def get_axes(self) -> None: ...
    def get_axis(self, index): ...
    def get_origin(self) -> np.ndarray: ...
    def get_x_axis(self): ...
    def get_y_axis(self): ...
    def get_z_axis(self): ...
    def get_x_unit_size(self): ...
    def get_y_unit_size(self): ...
    def get_x_axis_label(self, label: float | str | Mobject, edge: Sequence[float] = ..., direction: Sequence[float] = ..., buff: float = ..., **kwargs) -> Mobject: ...
    def get_y_axis_label(self, label: float | str | Mobject, edge: Sequence[float] = ..., direction: Sequence[float] = ..., buff: float = ..., **kwargs): ...
    axis_labels: Incomplete
    def get_axis_labels(self, x_label: float | str | Mobject = ..., y_label: float | str | Mobject = ...) -> VGroup: ...
    coordinate_labels: Incomplete
    def add_coordinates(self, *axes_numbers: Iterable[float] | None | dict[float, str | float | Mobject], **kwargs): ...
    def get_line_from_axis_to_point(self, index: int, point: Sequence[float], line_func: Line = ..., line_config: dict | None = ..., color: Color | None = ..., stroke_width: float = ...) -> Line: ...
    def get_vertical_line(self, point: Sequence[float], **kwargs) -> Line: ...
    def get_horizontal_line(self, point: Sequence[float], **kwargs) -> Line: ...
    def get_lines_to_point(self, point: Sequence[float], **kwargs) -> VGroup: ...
    def plot(self, function: Callable[[float], float], x_range: Sequence[float] | None = ..., use_vectorized: bool = ..., **kwargs): ...
    def plot_implicit_curve(self, func: Callable, min_depth: int = ..., max_quads: int = ..., **kwargs) -> ImplicitFunction: ...
    def plot_parametric_curve(self, function: Callable[[float], np.ndarray], use_vectorized: bool = ..., **kwargs) -> ParametricFunction: ...
    def plot_polar_graph(self, r_func: Callable[[float], float], theta_range: Sequence[float] = ..., **kwargs) -> ParametricFunction: ...
    def plot_surface(self, function: Callable[[float], float], u_range: Sequence[float] | None = ..., v_range: Sequence[float] | None = ..., colorscale: Sequence[[color], float] | None = ..., colorscale_axis: int = ..., **kwargs): ...
    def input_to_graph_point(self, x: float, graph: ParametricFunction | VMobject) -> np.ndarray: ...
    def input_to_graph_coords(self, x: float, graph: ParametricFunction) -> tuple: ...
    def i2gc(self, x: float, graph: ParametricFunction) -> tuple: ...
    def i2gp(self, x: float, graph: ParametricFunction) -> np.ndarray: ...
    def get_graph_label(self, graph: ParametricFunction, label: float | str | Mobject = ..., x_val: float | None = ..., direction: Sequence[float] = ..., buff: float = ..., color: Color | None = ..., dot: bool = ..., dot_config: dict | None = ...) -> Mobject: ...
    def get_riemann_rectangles(self, graph: ParametricFunction, x_range: Sequence[float] | None = ..., dx: float | None = ..., input_sample_type: str = ..., stroke_width: float = ..., stroke_color: Color = ..., fill_opacity: float = ..., color: Iterable[Color] | Color = ..., show_signed_area: bool = ..., bounded_graph: ParametricFunction = ..., blend: bool = ..., width_scale_factor: float = ...) -> VGroup: ...
    def get_area(self, graph: ParametricFunction, x_range: tuple[float, float] | None = ..., color: Color | Iterable[Color] = ..., opacity: float = ..., bounded_graph: ParametricFunction = ..., **kwargs): ...
    def angle_of_tangent(self, x: float, graph: ParametricFunction, dx: float = ...) -> float: ...
    def slope_of_tangent(self, x: float, graph: ParametricFunction, **kwargs) -> float: ...
    def plot_derivative_graph(self, graph: ParametricFunction, color: Color = ..., **kwargs) -> ParametricFunction: ...
    def plot_antiderivative_graph(self, graph: ParametricFunction, y_intercept: float = ..., samples: int = ..., use_vectorized: bool = ..., **kwargs): ...
    def get_secant_slope_group(self, x: float, graph: ParametricFunction, dx: float | None = ..., dx_line_color: Color = ..., dy_line_color: Color | None = ..., dx_label: float | str | None = ..., dy_label: float | str | None = ..., include_secant_line: bool = ..., secant_line_color: Color = ..., secant_line_length: float = ...) -> VGroup: ...
    def get_vertical_lines_to_graph(self, graph: ParametricFunction, x_range: Sequence[float] | None = ..., num_lines: int = ..., **kwargs) -> VGroup: ...
    def get_T_label(self, x_val: float, graph: ParametricFunction, label: float | str | Mobject | None = ..., label_color: Color | None = ..., triangle_size: float = ..., triangle_color: Color | None = ..., line_func: Line = ..., line_color: Color = ...) -> VGroup: ...

class Axes(VGroup, CoordinateSystem, metaclass=ConvertToOpenGL):
    axis_config: Incomplete
    x_axis_config: Incomplete
    y_axis_config: Incomplete
    x_axis: Incomplete
    y_axis: Incomplete
    axes: Incomplete
    def __init__(self, x_range: Sequence[float] | None = ..., y_range: Sequence[float] | None = ..., x_length: float | None = ..., y_length: float | None = ..., axis_config: dict | None = ..., x_axis_config: dict | None = ..., y_axis_config: dict | None = ..., tips: bool = ..., **kwargs) -> None: ...
    def coords_to_point(self, *coords: float | Sequence[float] | Sequence[Sequence[float]] | np.ndarray) -> np.ndarray: ...
    def point_to_coords(self, point: Sequence[float]) -> np.ndarray: ...
    def get_axes(self) -> VGroup: ...
    def plot_line_graph(self, x_values: Iterable[float], y_values: Iterable[float], z_values: Iterable[float] | None = ..., line_color: Color = ..., add_vertex_dots: bool = ..., vertex_dot_radius: float = ..., vertex_dot_style: dict | None = ..., **kwargs) -> VDict: ...

class ThreeDAxes(Axes):
    z_range: Incomplete
    z_length: Incomplete
    z_axis_config: Incomplete
    z_normal: Incomplete
    num_axis_pieces: Incomplete
    light_source: Incomplete
    dimension: int
    z_axis: Incomplete
    def __init__(self, x_range: Sequence[float] | None = ..., y_range: Sequence[float] | None = ..., z_range: Sequence[float] | None = ..., x_length: float | None = ..., y_length: float | None = ..., z_length: float | None = ..., z_axis_config: dict | None = ..., z_normal: Sequence[float] = ..., num_axis_pieces: int = ..., light_source: Sequence[float] = ..., depth: Incomplete | None = ..., gloss: float = ..., **kwargs) -> None: ...
    def get_z_axis_label(self, label: float | str | Mobject, edge: Sequence[float] = ..., direction: Sequence[float] = ..., buff: float = ..., rotation=..., rotation_axis=..., **kwargs) -> Mobject: ...

class NumberPlane(Axes):
    axis_config: Incomplete
    y_axis_config: Incomplete
    background_line_style: Incomplete
    faded_line_style: Incomplete
    faded_line_ratio: Incomplete
    make_smooth_after_applying_functions: Incomplete
    def __init__(self, x_range: Sequence[float] | None = ..., y_range: Sequence[float] | None = ..., x_length: float | None = ..., y_length: float | None = ..., background_line_style: dict | None = ..., faded_line_style: dict | None = ..., faded_line_ratio: int = ..., make_smooth_after_applying_functions: bool = ..., **kwargs) -> None: ...
    def get_vector(self, coords: Sequence[float], **kwargs): ...
    def prepare_for_nonlinear_transform(self, num_inserted_curves: int = ...): ...

class PolarPlane(Axes):
    azimuth_units: Incomplete
    azimuth_direction: Incomplete
    radius_config: Incomplete
    background_line_style: Incomplete
    azimuth_step: Incomplete
    faded_line_style: Incomplete
    faded_line_ratio: Incomplete
    make_smooth_after_applying_functions: Incomplete
    azimuth_offset: Incomplete
    azimuth_label_buff: Incomplete
    azimuth_label_font_size: Incomplete
    azimuth_compact_fraction: Incomplete
    def __init__(self, radius_max: float = ..., size: float | None = ..., radius_step: float = ..., azimuth_step: float | None = ..., azimuth_units: str | None = ..., azimuth_compact_fraction: bool = ..., azimuth_offset: float = ..., azimuth_direction: str = ..., azimuth_label_buff: float = ..., azimuth_label_font_size: float = ..., radius_config: dict | None = ..., background_line_style: dict | None = ..., faded_line_style: dict | None = ..., faded_line_ratio: int = ..., make_smooth_after_applying_functions: bool = ..., **kwargs) -> None: ...
    def get_axes(self) -> VGroup: ...
    def get_vector(self, coords, **kwargs): ...
    def prepare_for_nonlinear_transform(self, num_inserted_curves: int = ...): ...
    coordinate_labels: Incomplete
    def get_coordinate_labels(self, r_values: Iterable[float] | None = ..., a_values: Iterable[float] | None = ..., **kwargs) -> VDict: ...
    def add_coordinates(self, r_values: Iterable[float] | None = ..., a_values: Iterable[float] | None = ...): ...
    def get_radian_label(self, number, font_size: int = ..., **kwargs): ...

class ComplexPlane(NumberPlane):
    def __init__(self, **kwargs) -> None: ...
    def number_to_point(self, number: float | complex) -> np.ndarray: ...
    def n2p(self, number: float | complex) -> np.ndarray: ...
    def point_to_number(self, point: Sequence[float]) -> complex: ...
    def p2n(self, point: Sequence[float]) -> complex: ...
    coordinate_labels: Incomplete
    def get_coordinate_labels(self, *numbers: Iterable[float | complex], **kwargs) -> VGroup: ...
    def add_coordinates(self, *numbers: Iterable[float | complex], **kwargs): ...

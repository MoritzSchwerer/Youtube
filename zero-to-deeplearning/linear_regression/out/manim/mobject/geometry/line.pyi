from manim.constants import *
from manim.utils.color import *
import numpy as np
from _typeshed import Incomplete
from colour import Color
from manim.mobject.geometry.arc import TipableVMobject
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from manim.utils.color import Colors
from typing import Any, Sequence

class Line(TipableVMobject):
    dim: int
    buff: Incomplete
    path_arc: Incomplete
    def __init__(self, start=..., end=..., buff: int = ..., path_arc: Incomplete | None = ..., **kwargs) -> None: ...
    def generate_points(self) -> None: ...
    def set_points_by_ends(self, start, end, buff: int = ..., path_arc: int = ...) -> None: ...
    init_points = generate_points
    def set_path_arc(self, new_value) -> None: ...
    start: Incomplete
    end: Incomplete
    def put_start_and_end_on(self, start: Sequence[float], end: Sequence[float]): ...
    def get_vector(self): ...
    def get_unit_vector(self): ...
    def get_angle(self): ...
    def get_projection(self, point: Sequence[float]) -> Sequence[float]: ...
    def get_slope(self): ...
    def set_angle(self, angle, about_point: Incomplete | None = ...): ...
    def set_length(self, length): ...

class DashedLine(Line):
    dash_length: Incomplete
    dashed_ratio: Incomplete
    def __init__(self, *args: Any, dash_length: float = ..., dashed_ratio: float = ..., **kwargs) -> None: ...
    def get_start(self) -> np.ndarray: ...
    def get_end(self) -> np.ndarray: ...
    def get_first_handle(self) -> np.ndarray: ...
    def get_last_handle(self) -> np.ndarray: ...

class TangentLine(Line):
    length: Incomplete
    d_alpha: Incomplete
    def __init__(self, vmob: VMobject, alpha: float, length: float = ..., d_alpha: float = ..., **kwargs) -> None: ...

class Elbow(VMobject, metaclass=ConvertToOpenGL):
    angle: Incomplete
    def __init__(self, width: float = ..., angle: float = ..., **kwargs) -> None: ...

class Arrow(Line):
    max_tip_length_to_length_ratio: Incomplete
    max_stroke_width_to_length_ratio: Incomplete
    initial_stroke_width: Incomplete
    def __init__(self, *args: Any, stroke_width: float = ..., buff: float = ..., max_tip_length_to_length_ratio: float = ..., max_stroke_width_to_length_ratio: float = ..., **kwargs) -> None: ...
    def scale(self, factor, scale_tips: bool = ..., **kwargs): ...
    def get_normal_vector(self) -> np.ndarray: ...
    normal_vector: Incomplete
    def reset_normal_vector(self): ...
    def get_default_tip_length(self) -> float: ...

class Vector(Arrow):
    buff: Incomplete
    def __init__(self, direction: list | np.ndarray = ..., buff: float = ..., **kwargs) -> None: ...
    def coordinate_label(self, integer_labels: bool = ..., n_dim: int = ..., color: Color | None = ..., **kwargs): ...

class DoubleArrow(Arrow):
    def __init__(self, *args: Any, **kwargs) -> None: ...

class Angle(VMobject, metaclass=ConvertToOpenGL):
    lines: Incomplete
    quadrant: Incomplete
    dot_distance: Incomplete
    elbow: Incomplete
    radius: Incomplete
    angle_value: Incomplete
    dot_radius: Incomplete
    def __init__(self, line1: Line, line2: Line, radius: float = ..., quadrant: Sequence[int] = ..., other_angle: bool = ..., dot: bool = ..., dot_radius: float | None = ..., dot_distance: float = ..., dot_color: Colors = ..., elbow: bool = ..., **kwargs) -> None: ...
    def get_lines(self) -> VGroup: ...
    def get_value(self, degrees: bool = ...) -> float: ...
    @staticmethod
    def from_three_points(A: np.ndarray, B: np.ndarray, C: np.ndarray, **kwargs) -> Angle: ...

class RightAngle(Angle):
    def __init__(self, line1: Line, line2: Line, length: float | None = ..., **kwargs) -> None: ...

from ...constants import *
import numpy as np
import typing
from ...mobject.mobject import Mobject
from PIL.Image import Image
from _typeshed import Incomplete
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from typing import Callable, Sequence

class VMobject(Mobject):
    sheen_factor: float
    fill_opacity: Incomplete
    stroke_opacity: Incomplete
    stroke_width: Incomplete
    background_stroke_color: Incomplete
    background_stroke_opacity: Incomplete
    background_stroke_width: Incomplete
    joint_type: Incomplete
    sheen_direction: Incomplete
    close_new_points: Incomplete
    pre_function_handle_to_anchor_scale_factor: Incomplete
    make_smooth_after_applying_functions: Incomplete
    background_image: Incomplete
    shade_in_3d: Incomplete
    tolerance_for_point_equality: Incomplete
    n_points_per_cubic_curve: Incomplete
    fill_color: Incomplete
    stroke_color: Incomplete
    def __init__(self, fill_color: Incomplete | None = ..., fill_opacity: float = ..., stroke_color: Incomplete | None = ..., stroke_opacity: float = ..., stroke_width=..., background_stroke_color=..., background_stroke_opacity: float = ..., background_stroke_width: int = ..., sheen_factor: float = ..., joint_type: LineJointType | None = ..., sheen_direction=..., close_new_points: bool = ..., pre_function_handle_to_anchor_scale_factor: float = ..., make_smooth_after_applying_functions: bool = ..., background_image: Incomplete | None = ..., shade_in_3d: bool = ..., tolerance_for_point_equality: float = ..., n_points_per_cubic_curve: int = ..., **kwargs) -> None: ...
    @property
    def n_points_per_curve(self): ...
    def get_group_class(self): ...
    @staticmethod
    def get_mobject_type_class(): ...
    def init_colors(self, propagate_colors: bool = ...): ...
    def generate_rgbas_array(self, color, opacity): ...
    def update_rgbas_array(self, array_name, color: Incomplete | None = ..., opacity: Incomplete | None = ...): ...
    def set_fill(self, color: str | None = ..., opacity: float | None = ..., family: bool = ...): ...
    def set_stroke(self, color: Incomplete | None = ..., width: Incomplete | None = ..., opacity: Incomplete | None = ..., background: bool = ..., family: bool = ...): ...
    def set_background_stroke(self, **kwargs): ...
    def set_style(self, fill_color: Incomplete | None = ..., fill_opacity: Incomplete | None = ..., stroke_color: Incomplete | None = ..., stroke_width: Incomplete | None = ..., stroke_opacity: Incomplete | None = ..., background_stroke_color: Incomplete | None = ..., background_stroke_width: Incomplete | None = ..., background_stroke_opacity: Incomplete | None = ..., sheen_factor: Incomplete | None = ..., sheen_direction: Incomplete | None = ..., background_image: Incomplete | None = ..., family: bool = ...): ...
    def get_style(self, simple: bool = ...): ...
    def match_style(self, vmobject, family: bool = ...): ...
    def set_color(self, color: str, family: bool = ...): ...
    def set_opacity(self, opacity, family: bool = ...): ...
    def fade(self, darkness: float = ..., family: bool = ...): ...
    def get_fill_rgbas(self): ...
    def get_fill_color(self): ...
    def get_fill_opacity(self): ...
    def get_fill_colors(self): ...
    def get_fill_opacities(self): ...
    def get_stroke_rgbas(self, background: bool = ...): ...
    def get_stroke_color(self, background: bool = ...): ...
    def get_stroke_width(self, background: bool = ...): ...
    def get_stroke_opacity(self, background: bool = ...): ...
    def get_stroke_colors(self, background: bool = ...): ...
    def get_stroke_opacities(self, background: bool = ...): ...
    def get_color(self): ...
    color: Incomplete
    def set_sheen_direction(self, direction: np.ndarray, family: bool = ...): ...
    def rotate_sheen_direction(self, angle: float, axis: np.ndarray = ..., family: bool = ...): ...
    def set_sheen(self, factor: float, direction: np.ndarray = ..., family: bool = ...): ...
    def get_sheen_direction(self): ...
    def get_sheen_factor(self): ...
    def get_gradient_start_and_end_points(self): ...
    def color_using_background_image(self, background_image: Image | str): ...
    def get_background_image(self) -> Image | str: ...
    def match_background_image(self, vmobject): ...
    def set_shade_in_3d(self, value: bool = ..., z_index_as_group: bool = ...): ...
    points: Incomplete
    def set_points(self, points): ...
    def resize_points(self, new_length: int, resize_func: Callable[[np.ndarray, int], np.ndarray] = ...): ...
    def set_anchors_and_handles(self, anchors1: Sequence[float], handles1: Sequence[float], handles2: Sequence[float], anchors2: Sequence[float]): ...
    def clear_points(self) -> None: ...
    def append_points(self, new_points): ...
    def start_new_path(self, point): ...
    def add_cubic_bezier_curve(self, anchor1: np.ndarray, handle1: np.ndarray, handle2: np.ndarray, anchor2) -> None: ...
    def add_cubic_bezier_curves(self, curves) -> None: ...
    def add_cubic_bezier_curve_to(self, handle1: np.ndarray, handle2: np.ndarray, anchor: np.ndarray): ...
    def add_quadratic_bezier_curve_to(self, handle: np.ndarray, anchor: np.ndarray): ...
    def add_line_to(self, point: np.ndarray): ...
    def add_smooth_curve_to(self, *points: np.array): ...
    def has_new_path_started(self): ...
    def get_last_point(self): ...
    def is_closed(self): ...
    def close_path(self) -> None: ...
    def add_points_as_corners(self, points: np.ndarray) -> VMobject: ...
    def set_points_as_corners(self, points: Sequence[float]): ...
    def set_points_smoothly(self, points): ...
    def change_anchor_mode(self, mode: str): ...
    def make_smooth(self): ...
    def make_jagged(self): ...
    def add_subpath(self, points: np.ndarray): ...
    def append_vectorized_mobject(self, vectorized_mobject) -> None: ...
    def apply_function(self, function): ...
    def rotate(self, angle: float, axis: np.ndarray = ..., about_point: Sequence[float] | None = ..., **kwargs): ...
    def scale_handle_to_anchor_distances(self, factor: float): ...
    def consider_points_equals(self, p0, p1): ...
    def consider_points_equals_2d(self, p0: np.ndarray, p1: np.ndarray) -> bool: ...
    def get_cubic_bezier_tuples_from_points(self, points): ...
    def gen_cubic_bezier_tuples_from_points(self, points: np.ndarray) -> tuple: ...
    def get_cubic_bezier_tuples(self): ...
    def get_subpaths_from_points(self, points): ...
    def gen_subpaths_from_points_2d(self, points): ...
    def get_subpaths(self) -> tuple: ...
    def get_nth_curve_points(self, n: int) -> np.ndarray: ...
    def get_nth_curve_function(self, n: int) -> typing.Callable[[float], np.ndarray]: ...
    def get_nth_curve_length_pieces(self, n: int, sample_points: int | None = ...) -> np.ndarray: ...
    def get_nth_curve_length(self, n: int, sample_points: int | None = ...) -> float: ...
    def get_nth_curve_function_with_length(self, n: int, sample_points: int | None = ...) -> tuple[typing.Callable[[float], np.ndarray], float]: ...
    def get_num_curves(self) -> int: ...
    def get_curve_functions(self) -> typing.Iterable[typing.Callable[[float], np.ndarray]]: ...
    def get_curve_functions_with_lengths(self, **kwargs) -> typing.Iterable[tuple[typing.Callable[[float], np.ndarray], float]]: ...
    def point_from_proportion(self, alpha: float) -> np.ndarray: ...
    def proportion_from_point(self, point: typing.Iterable[float | int]) -> float: ...
    def get_anchors_and_handles(self) -> typing.Iterable[np.ndarray]: ...
    def get_start_anchors(self) -> np.ndarray: ...
    def get_end_anchors(self) -> np.ndarray: ...
    def get_anchors(self) -> np.ndarray: ...
    def get_points_defining_boundary(self): ...
    def get_arc_length(self, sample_points_per_curve: int | None = ...) -> float: ...
    def align_points(self, vmobject: VMobject): ...
    def insert_n_curves(self, n: int): ...
    def insert_n_curves_to_point_list(self, n: int, points: np.ndarray) -> np.ndarray: ...
    def align_rgbas(self, vmobject): ...
    def get_point_mobject(self, center: Incomplete | None = ...): ...
    def interpolate_color(self, mobject1, mobject2, alpha) -> None: ...
    def pointwise_become_partial(self, vmobject: VMobject, a: float, b: float): ...
    def get_subcurve(self, a: float, b: float) -> VMobject: ...
    def get_direction(self): ...
    def reverse_direction(self): ...
    def force_direction(self, target_direction: str): ...

class VGroup(VMobject, metaclass=ConvertToOpenGL):
    def __init__(self, *vmobjects, **kwargs) -> None: ...
    def add(self, *vmobjects: VMobject): ...
    def __add__(self, vmobject): ...
    def __iadd__(self, vmobject): ...
    def __sub__(self, vmobject): ...
    def __isub__(self, vmobject): ...
    def __setitem__(self, key: int, value: VMobject | typing.Sequence[VMobject]): ...

class VDict(VMobject, metaclass=ConvertToOpenGL):
    show_keys: Incomplete
    submob_dict: Incomplete
    def __init__(self, mapping_or_iterable: typing.Mapping[typing.Hashable, VMobject] | typing.Iterable[tuple[typing.Hashable, VMobject]] = ..., show_keys: bool = ..., **kwargs) -> None: ...
    def add(self, mapping_or_iterable: typing.Mapping[typing.Hashable, VMobject] | typing.Iterable[tuple[typing.Hashable, VMobject]]): ...
    def remove(self, key: typing.Hashable): ...
    def __getitem__(self, key: typing.Hashable): ...
    def __setitem__(self, key: typing.Hashable, value: VMobject): ...
    def __delitem__(self, key: typing.Hashable): ...
    def __contains__(self, key: typing.Hashable): ...
    def get_all_submobjects(self): ...
    def add_key_value_pair(self, key: typing.Hashable, value: VMobject): ...

class VectorizedPoint(VMobject, metaclass=ConvertToOpenGL):
    artificial_width: Incomplete
    artificial_height: Incomplete
    def __init__(self, location=..., color=..., fill_opacity: int = ..., stroke_width: int = ..., artificial_width: float = ..., artificial_height: float = ..., **kwargs) -> None: ...
    basecls: Incomplete
    def width(self): ...
    def height(self): ...
    def get_location(self): ...
    def set_location(self, new_loc) -> None: ...

class CurvesAsSubmobjects(VGroup):
    def __init__(self, vmobject, **kwargs) -> None: ...

class DashedVMobject(VMobject, metaclass=ConvertToOpenGL):
    dashed_ratio: Incomplete
    num_dashes: Incomplete
    def __init__(self, vmobject, num_dashes: int = ..., dashed_ratio: float = ..., dash_offset: int = ..., color=..., equal_lengths: bool = ..., **kwargs) -> None: ...

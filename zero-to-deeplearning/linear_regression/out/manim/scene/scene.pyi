from ..constants import *
from ..animation.animation import Animation
from _typeshed import Incomplete
from manim.mobject.mobject import Mobject
from typing import Callable
from watchdog.events import FileSystemEventHandler

class RerunSceneHandler(FileSystemEventHandler):
    queue: Incomplete
    def __init__(self, queue) -> None: ...
    def on_modified(self, event) -> None: ...

class Scene:
    camera_class: Incomplete
    always_update_mobjects: Incomplete
    random_seed: Incomplete
    skip_animations: Incomplete
    animations: Incomplete
    stop_condition: Incomplete
    moving_mobjects: Incomplete
    static_mobjects: Incomplete
    time_progression: Incomplete
    duration: Incomplete
    last_t: Incomplete
    queue: Incomplete
    skip_animation_preview: bool
    meshes: Incomplete
    camera_target: Incomplete
    widgets: Incomplete
    dearpygui_imported: Incomplete
    updaters: Incomplete
    point_lights: Incomplete
    ambient_light: Incomplete
    key_to_function_map: Incomplete
    mouse_press_callbacks: Incomplete
    interactive_mode: bool
    mouse_point: Incomplete
    mouse_drag_point: Incomplete
    renderer: Incomplete
    mobjects: Incomplete
    foreground_mobjects: Incomplete
    def __init__(self, renderer: Incomplete | None = ..., camera_class=..., always_update_mobjects: bool = ..., random_seed: Incomplete | None = ..., skip_animations: bool = ...) -> None: ...
    @property
    def camera(self): ...
    def __deepcopy__(self, clone_from_id): ...
    def render(self, preview: bool = ...): ...
    def setup(self) -> None: ...
    def tear_down(self) -> None: ...
    def construct(self) -> None: ...
    def next_section(self, name: str = ..., type: str = ..., skip_animations: bool = ...) -> None: ...
    def get_attrs(self, *keys: str): ...
    def update_mobjects(self, dt: float): ...
    def update_meshes(self, dt) -> None: ...
    def update_self(self, dt: float): ...
    def should_update_mobjects(self) -> bool: ...
    def get_top_level_mobjects(self): ...
    def get_mobject_family_members(self): ...
    def add(self, *mobjects: Mobject): ...
    def add_mobjects_from_animations(self, animations) -> None: ...
    def remove(self, *mobjects: Mobject): ...
    def add_updater(self, func: Callable[[float], None]) -> None: ...
    def remove_updater(self, func: Callable[[float], None]) -> None: ...
    def restructure_mobjects(self, to_remove: Mobject, mobject_list_name: str = ..., extract_families: bool = ...): ...
    def get_restructured_mobject_list(self, mobjects: list, to_remove: list): ...
    def add_foreground_mobjects(self, *mobjects: Mobject): ...
    def add_foreground_mobject(self, mobject: Mobject): ...
    def remove_foreground_mobjects(self, *to_remove: Mobject): ...
    def remove_foreground_mobject(self, mobject: Mobject): ...
    def bring_to_front(self, *mobjects: Mobject): ...
    def bring_to_back(self, *mobjects: Mobject): ...
    def clear(self): ...
    def get_moving_mobjects(self, *animations: Animation): ...
    def get_moving_and_static_mobjects(self, animations): ...
    def compile_animations(self, *args: Animation, **kwargs): ...
    def get_time_progression(self, run_time: float, description, n_iterations: int | None = ..., override_skip_animations: bool = ...): ...
    def get_run_time(self, animations: list[Animation]): ...
    def play(self, *args, subcaption: Incomplete | None = ..., subcaption_duration: Incomplete | None = ..., subcaption_offset: int = ..., **kwargs) -> None: ...
    def wait(self, duration: float = ..., stop_condition: Callable[[], bool] | None = ..., frozen_frame: bool | None = ...): ...
    def pause(self, duration: float = ...): ...
    def wait_until(self, stop_condition: Callable[[], bool], max_time: float = ...): ...
    def compile_animation_data(self, *animations: Animation, **play_kwargs): ...
    def begin_animations(self) -> None: ...
    def is_current_animation_frozen_frame(self) -> bool: ...
    def play_internal(self, skip_rendering: bool = ...): ...
    def check_interactive_embed_is_valid(self): ...
    def interactive_embed(self): ...
    quit_interaction: bool
    def interact(self, shell, keyboard_thread) -> None: ...
    def embed(self): ...
    def update_to_time(self, t) -> None: ...
    def add_subcaption(self, content: str, duration: float = ..., offset: float = ...) -> None: ...
    def add_sound(self, sound_file: str, time_offset: float = ..., gain: float | None = ..., **kwargs): ...
    def on_mouse_motion(self, point, d_point) -> None: ...
    def on_mouse_scroll(self, point, offset) -> None: ...
    def on_key_press(self, symbol, modifiers) -> None: ...
    def on_key_release(self, symbol, modifiers) -> None: ...
    def on_mouse_drag(self, point, d_point, buttons, modifiers) -> None: ...
    def mouse_scroll_orbit_controls(self, point, offset) -> None: ...
    def mouse_drag_orbit_controls(self, point, d_point, buttons, modifiers) -> None: ...
    def set_key_function(self, char, func) -> None: ...
    def on_mouse_press(self, point, button, modifiers) -> None: ...
